import pg from 'pg';
import dns from 'dns';

const { Pool } = pg;

let pool: pg.Pool;

const shouldUseSsl = (databaseUrl: string) => {
  // Supabase requires SSL in hosted environments. Local Postgres typically doesn't.
  if (process.env.DATABASE_SSL) return process.env.DATABASE_SSL === 'true';
  return !databaseUrl.includes('localhost') && !databaseUrl.includes('127.0.0.1');
};

export const initDatabase = async () => {
  const databaseUrl = process.env.DATABASE_URL;
  if (!databaseUrl) {
    throw new Error('DATABASE_URL is required (use your Supabase Postgres connection string).');
  }

  // Parse connection string so we can force IPv4 (helps on hosts without IPv6 routes).
  const url = new URL(databaseUrl);
  const host = url.hostname;
  const port = url.port ? Number(url.port) : 5432;
  const database = url.pathname.replace(/^\//, '') || 'postgres';
  const user = decodeURIComponent(url.username);
  const password = decodeURIComponent(url.password);

  // Resolve to IPv4 address explicitly to avoid ENETUNREACH on IPv6-only resolutions.
  const { address } = await dns.promises.lookup(host, { family: 4 });

  pool = new Pool({
    host: address,
    port,
    database,
    user,
    password,
    ssl: shouldUseSsl(databaseUrl) ? { rejectUnauthorized: false } : undefined
  });

  // Verify connection early (and fail fast on deploy misconfig).
  await pool.query('SELECT 1');

  // Create tables if they don't exist (works in Supabase public schema).
  await pool.query(`
    CREATE TABLE IF NOT EXISTS users (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      password TEXT NOT NULL,
      name TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS orders (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      patient_name TEXT NOT NULL,
      patient_rx TEXT,
      status TEXT NOT NULL DEFAULT 'Open',
      order_type TEXT NOT NULL DEFAULT 'Stock',
      date_created TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      due_date TIMESTAMPTZ NOT NULL,
      created_by BIGINT REFERENCES users(id)
    );
  `);

  // Add order_type to existing tables (no-op if column already exists)
  await pool.query(`
    DO $$ BEGIN
      ALTER TABLE orders ADD COLUMN order_type TEXT DEFAULT 'Stock';
    EXCEPTION WHEN duplicate_column THEN NULL; END $$;

    CREATE TABLE IF NOT EXISTS comments (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
      user_id BIGINT NOT NULL REFERENCES users(id),
      comment TEXT NOT NULL,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE TABLE IF NOT EXISTS order_history (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      order_id BIGINT NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
      user_id BIGINT NOT NULL REFERENCES users(id),
      field_name TEXT NOT NULL,
      old_value TEXT,
      new_value TEXT,
      created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );
  `);

  console.log('Connected to Postgres database');
};

export const dbRun = async (sql: string, params: any[] = []) => {
  const result = await pool.query(sql, params);
  const lastID = result.rows?.[0]?.id ? Number(result.rows[0].id) : 0;
  return { lastID, changes: result.rowCount ?? 0 };
};

export const dbGet = async (sql: string, params: any[] = []) => {
  const result = await pool.query(sql, params);
  return result.rows[0];
};

export const dbAll = async (sql: string, params: any[] = []) => {
  const result = await pool.query(sql, params);
  return result.rows || [];
};

